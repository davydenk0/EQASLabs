**Опис проблеми:**
>Нехай у нас є клас Calculator, і в ньому є метод calculate, який виконує ряд арифметичних операцій.

**Аналіз проблеми:**
>Цей метод містить багато умовних перевірок, що робить його складним для розуміння та підтримки.
Код не є відповідним до принципу SOLID, зокрема, до принципу єдиного обов'язку (Single Responsibility Principle), оскільки він виконує кілька різних операцій.
Поганий механізм обробки помилок у випадку ділення на нуль.

**Оптимізація методу:**
>Оптимізація полягала у переробці методу calculate таким чином, щоб він більш відповідав принципам доброї архітектури та програмування. Ось деякі зміни, які були внесені:1
> 1. Використання паттерну стратегії: Замість одного великого методу, що виконує різні операції залежно від переданого параметру operation, було вирішено розділити ці операції на окремі методи в межах класу Calculator. Це дозволило кожному методу відповідати за конкретну операцію, що робить код більш зрозумілим та легким для розширення.
> 2. Збереження принципу єдиного обов'язку (Single Responsibility Principle): Кожен метод у класі Calculator тепер відповідає лише за виконання однієї конкретної операції. Це дозволяє класу мати один чіткий обов'язок, що спрощує його розуміння та підтримку.
> 3. Покращення обробки помилок: У покращеному варіанті методу divide виконує перевірку на ділення на нуль та повертає None, якщо це відбувається. Це забезпечує більш коректну обробку помилок та уникнення непередбачуваних станів програми.
> 
>Ці зміни дозволяють покращити якість коду, роблять його більш гнучким та підтримуваним, а також дозволяють легше розширювати функціональність у майбутньому без потреби змінювати вже наявний код.

**Результати:**

>Тепер у нашому класі Calculator кожен метод відповідає лише одному виду операції, що дозволяє зробити код більш зрозумілим та легким для підтримки.
>> calculator = Calculator()
print(calculator.calculate(5, 3, calculator.add))  # 8
print(calculator.calculate(5, 3, calculator.subtract))  # 2
print(calculator.calculate(5, 3, calculator.multiply))  # 15
print(calculator.calculate(5, 0, calculator.divide))  # None
>
>Ця оптимізація полегшує розширення функціональності калькулятора та дозволяє використовувати його в інших частинах програми без необхідності змінювати сам клас Calculator.